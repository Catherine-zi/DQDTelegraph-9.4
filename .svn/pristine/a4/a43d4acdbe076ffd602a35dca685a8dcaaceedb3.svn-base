//
//  OCLanguage.m
//  DQDTelegraphDemo
//
//  Created by AVAZU on 2018/7/4.
//  Copyright © 2018年 Avazu. All rights reserved.
//

#import "OCLanguage.h"

@implementation OCLanguage

+ (NSString *)SWLocalizedString:(NSString *)key {
    
    NSString *resource = @"";
    if ([[NSUserDefaults standardUserDefaults] objectForKey:@"BitUpAppLanguageKey"] == nil) {
       NSString *languageCode = [[NSLocale preferredLanguages] firstObject];
        
//        NSString *resource = @"";
        if ([languageCode hasPrefix:@"zh-Hans"]) {
            resource = @"zh-Hans";
        } else if ([languageCode hasPrefix:@"zh-Hant"])  {
            resource = @"zh-Hant";
        } else if ([languageCode hasPrefix:@"ja"])  {
            resource = @"ja";
        } else if ([languageCode hasPrefix:@"ko"])  {
            resource = @"ko";
        } else if ([languageCode hasPrefix:@"ru"])  {
            resource = @"ru";
        } else {
            resource = @"en";
        }
    } else {
        resource = [[NSUserDefaults standardUserDefaults] objectForKey:@"BitUpAppLanguageKey"];
    }
    NSString *path = [[NSBundle mainBundle] pathForResource:resource ofType:@"lproj"];
    return [[NSBundle bundleWithPath:path] localizedStringForKey:key value:nil table:@"Localizable"];
}
    
+ (NSData*)swdataFromHex:(NSString *)hexString {
    return [OCLanguage swdataWithHexCString:[hexString cStringUsingEncoding:NSASCIIStringEncoding]];
}
    
+ (NSData*)swdataWithHexCString:(const char*)hexCString {
    if (hexCString == NULL) return nil;
    
    const unsigned char *psz = (const unsigned char*)hexCString;
    
    while (isspace(*psz)) psz++;
    
    // Skip optional 0x prefix
    if (psz[0] == '0' && tolower(psz[1]) == 'x') psz += 2;
    
    while (isspace(*psz)) psz++;
    
    size_t len = strlen((const char*)psz);
    
    // If the string is not full number of bytes (each byte 2 hex characters), return nil.
    //        if (len % 2 != 0) return nil;
    
    unsigned char* buf = (unsigned char*)malloc(len/2);
    
    static const signed char digits[256] = {
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1,
        -1,0xa,0xb,0xc,0xd,0xe,0xf, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1,0xa,0xb,0xc,0xd,0xe,0xf, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
    
    unsigned char* bufpointer = buf;
    
    while (1) {
        unsigned char c1 = (unsigned char)*psz++;
        signed char n1 = digits[c1];
        if (n1 == (signed char)-1) break; // break when null-terminator is hit
        
        unsigned char c2 = (unsigned char)*psz++;
        signed char n2 = digits[c2];
        if (n2 == (signed char)-1) break; // break when null-terminator is hit
        
        *bufpointer = (unsigned char)((n1 << 4) | n2);
        bufpointer++;
    }
    
    return [[NSData alloc] initWithBytesNoCopy:buf length:len/2];
}

@end
